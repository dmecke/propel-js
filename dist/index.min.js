"use strict";export var physics;(function(x){let g;(function(e){e[e.CIRCLE=0]="CIRCLE",e[e.RECTANGLE=1]="RECTANGLE"})(g=x.ShapeType||(x.ShapeType={}));function D(e,t){return[...t??e.dynamicBodies,...e.staticBodies,...e.disabledBodies]}x.allBodies=D;function _(e,t){return[...t??e.dynamicBodies,...e.staticBodies]}x.enabledBodies=_;function ie(e,t,i){const c=(i??e.dynamicBodies).findIndex(o=>o.id===t.id);c!==-1&&(i??e.dynamicBodies).splice(c,1);const a=e.staticBodies.findIndex(o=>o.id===t.id);a!==-1&&e.staticBodies.splice(a,1),e.disabledBodies.includes(t)||e.disabledBodies.push(t)}x.disableBody=ie;function ne(e,t,i){!t.static&&!(i??e.dynamicBodies).find(c=>c.id===t.id)&&(i??e.dynamicBodies).push(t),t.static&&!e.staticBodies.includes(t)&&e.staticBodies.push(t),e.disabledBodies.includes(t)&&e.disabledBodies.splice(e.disabledBodies.indexOf(t),1)}x.enableBody=ne;function ae(e,t=!1,i){const c=t?e.staticBodies:D(e,i);if(c.length===0)return{min:m(0,0),max:m(0,0)};const a=c[0];let o=m(a.shapes[0].center.x-a.shapes[0].bounds,a.center.y-a.shapes[0].bounds),n=m(a.shapes[0].center.x+a.shapes[0].bounds,a.center.y+a.shapes[0].bounds);for(const u of c)for(const s of u.shapes)if(s.type===g.CIRCLE)o.x=Math.min(o.x,s.center.x-s.bounds),o.y=Math.min(o.y,s.center.y-s.bounds),n.x=Math.max(n.x,s.center.x+s.bounds),n.y=Math.max(n.y,s.center.y+s.bounds);else if(s.type===g.RECTANGLE)for(const r of s.vertices)o.x=Math.min(o.x,r.x),o.y=Math.min(o.y,r.y),n.x=Math.max(n.x,r.x),n.y=Math.max(n.y,r.y);return{min:o,max:n}}x.getWorldBounds=ae;function oe(e,t=1){return{staticBodies:[],dynamicBodies:[],disabledBodies:[],gravity:e??m(0,100),angularDamp:1,damp:1,nextId:1,joints:[],frameCount:0,jointRestriction:1,restTime:t,exclusions:{}}}x.createWorld=oe;function ce(e,t,i){e.exclusions[t.id]=e.exclusions[t.id]??[],e.exclusions[t.id].includes(i.id)||e.exclusions[t.id].push(i.id),e.exclusions[i.id]=e.exclusions[i.id]??[],e.exclusions[i.id].includes(t.id)||e.exclusions[i.id].push(t.id)}x.excludeCollisions=ce;function se(e,t,i){e.exclusions[t.id]&&(e.exclusions[t.id]=e.exclusions[t.id].filter(c=>i.id===c)),e.exclusions[i.id]&&(e.exclusions[i.id]=e.exclusions[t.id].filter(c=>t.id===c))}x.includeCollisions=se;function re(e,t,i,c=1,a=0,o=!1){e.joints.push({bodyA:t.id,bodyB:i.id,distance:M(p(t.center,i.center))+.5,rigidity:c,elasticity:a,soft:o})}x.createJoint=re;function fe(e,t,i,c,a,o,n=!1,u){const s=Q(t,i,n);return F(e,t,c,a,o,[s],u)}x.createCircle=fe;function ue(e,t,i,c,a,o,n,u=!1,s){const r=U(t,i,c,0,u);return F(e,t,a,o,n,[r],s)}x.createRectangle=ue;function H(e,t){A(e,t,!0)}x.moveBody=H;function A(e,t,i=!1){if(!(!i&&e.static)){e.center=B(e.center,t),e.static||(e.centerOfPhysics=B(e.centerOfPhysics,t));for(const c of e.shapes)if(c.center=B(c.center,t),c.type===g.RECTANGLE){for(let a=4;a--;)c.vertices[a]=B(c.vertices[a],t);Z(c)}}}function le(e,t){const i=p(t,e.center);H(e,i)}x.setCenter=le;function de(e,t){const i=t-e.angle;e.static||(e.centerOfPhysics={...e.center}),W(e,i)}x.setRotation=de;function W(e,t){if(!t)return;e.angle+=t,e.static||(e.averageAngle=t);const i=e.static?e.center:e.centerOfPhysics;e.center=T(e.center,i,t);for(const c of e.shapes)if(c.center=T(c.center,i,t),c.type===g.RECTANGLE){for(let a=4;a--;)c.vertices[a]=T(c.vertices[a],i,t);Be(c),Z(c)}}x.rotateBody=W;function xe(e,t,i){i=i??t.dynamicBodies;const c=_(t,i),a=D(t,i),o=[];for(const n of a)n.shapes.forEach(u=>{!n.static&&n.restingTime>t.restTime||(u.sensorColliding=!1)});for(const n of i)!n.velocity&&!n.acceleration||P(t,n)||(n.fixedPosition?(n.velocity.x=0,n.velocity.y=0):(n.velocity=B(n.velocity,d(n.acceleration,1/e)),A(n,d(n.velocity,1/e))),n.fixedRotation?(n.angularVelocity=0,n.angularAcceleration=0):(n.angularVelocity+=n.angularAcceleration*1/e,W(n,n.angularVelocity*1/e)));for(const n of i){const u=t.joints.filter(s=>s.bodyA===n.id||s.bodyB===n.id);for(const s of u){const r=s.bodyA===n.id?s.bodyB:s.bodyA,y=a.find(f=>f.id===r);if(y){let f=p(y.center,n.center);const l=M(f),v=l-s.distance;v!=0&&(v>0?f=d(f,1/l*v*(1-s.elasticity)*(y.static?1:.5)):f=d(f,1/l*v*s.rigidity*(y.static?1:.5)),s.soft||A(n,f),n.velocity=B(n.velocity,d(f,e))),(n.static||y.static)&&(n.static||(n.velocity.x-=n.velocity.x*(1-t.damp)/e*t.jointRestriction,n.velocity.y-=n.velocity.y*(1-t.damp)/e*t.jointRestriction,n.angularVelocity-=n.angularVelocity*(1-t.angularDamp)/e*t.jointRestriction),y.static||(y.velocity.x-=y.velocity.x*(1-t.damp)/e*t.jointRestriction,y.velocity.y-=y.velocity.y*(1-t.damp)/e*t.jointRestriction,y.angularVelocity-=y.angularVelocity*(1-t.angularDamp)/e*t.jointRestriction))}}}for(let n=9;n--;){let u=!1;for(let s=i.length;s--;){const r=i[s];if(r.velocity)for(let y=c.length;y-- >s;){if(s===y)continue;const f=c[y];if(!t.exclusions[f.id]?.includes(r.id)&&!t.exclusions[r.id]?.includes(f.id)&&ge(r,f)){let l=k();if(he(t,r,f,l)){if(f.permeability>0){r.velocity.x*=1-f.permeability,r.velocity.y*=1-f.permeability,r.angularVelocity*=1-f.permeability;continue}r.static||(r.shapes.includes(l.shapeA)&&(r.centerOfPhysics={...l.shapeA.center},r.inertia=l.shapeA.inertia),r.shapes.includes(l.shapeB)&&(r.centerOfPhysics={...l.shapeB.center},r.inertia=l.shapeB.inertia)),f.static||(f.shapes.includes(l.shapeA)&&(f.centerOfPhysics={...l.shapeA.center},f.inertia=l.shapeA.inertia),f.shapes.includes(l.shapeB)&&(f.centerOfPhysics={...l.shapeB.center},f.inertia=l.shapeB.inertia)),R(l.normal,p(f.center,r.center))<0&&(l={depth:l.depth,normal:d(l.normal,-1),start:l.end,end:l.start,shapeA:l.shapeB,shapeB:l.shapeA}),ve(t,r,f,l)&&(u=!0,o.push({bodyAId:r.id,bodyBId:f.id,depth:l.depth}))}}}}if(!u)break}for(const n of i)n.restingTime+=1/e,Math.abs(n.center.x-n.averageCenter.x)>.1&&(n.averageCenter.x=n.center.x,n.restingTime=0),Math.abs(n.center.y-n.averageCenter.y)>.1&&(n.averageCenter.y=n.center.y,n.restingTime=0),Math.abs(n.angle-n.averageAngle)>=.05&&(n.averageAngle=n.angle,n.restingTime=0);return o}x.worldStep=xe;function ye(e,t=1,i){return!(i??e.dynamicBodies).find(c=>c.restingTime<t)}x.atRest=ye;function m(e,t){return{x:e,y:t}}x.newVec2=m;function M(e){return R(e,e)**.5}x.lengthVec2=M;function B(e,t){return m(e.x+t.x,e.y+t.y)}x.addVec2=B;function p(e,t){return B(e,d(t,-1))}x.subtractVec2=p;function d(e,t){return m(e.x*t,e.y*t)}x.scaleVec2=d;function R(e,t){return e.x*t.x+e.y*t.y}x.dotProduct=R;function N(e,t){return e.x*t.y-e.y*t.x}x.crossProduct=N;function T(e,t,i){const c=e.x-t.x,a=e.y-t.y;return m(c*Math.cos(i)-a*Math.sin(i)+t.x,c*Math.sin(i)+a*Math.cos(i)+t.y)}x.rotateVec2=T;function V(e){return d(e,1/(M(e)||1))}x.normalize=V;const k=()=>({depth:0,normal:m(0,0),start:m(0,0),end:m(0,0),shapeA:void 0,shapeB:void 0});function E(e,t,i,c,a,o){if(!(e.depth>=t)){if(a.sensor){a.sensorColliding=!0;return}if(o.sensor){o.sensorColliding=!0;return}e.depth=t,e.normal.x=i.x,e.normal.y=i.y,e.start.x=c.x,e.start.y=c.y,e.end=B(c,d(i,t)),e.shapeA=a,e.shapeB=o}}function K(e,t){return e.type===g.RECTANGLE?(Math.hypot(e.width,e.height)/2,t>0?1/(t*(e.width**2+e.height**2)/12):0):t>0?t*e.bounds**2/12:0}function Q(e,t,i=!1){return e.x=Math.floor(e.x),e.y=Math.floor(e.y),t=Math.floor(t),{type:g.CIRCLE,center:e,bounds:t,boundingBox:J(g.CIRCLE,t,[],e),sensor:i,sensorColliding:!1,inertia:0}}x.createCircleShape=Q;function U(e,t,i,c=0,a=!1){e.x=Math.floor(e.x),e.y=Math.floor(e.y),t=Math.floor(t),i=Math.floor(i);const o=[m(e.x-t/2,e.y-i/2),m(e.x+t/2,e.y-i/2),m(e.x+t/2,e.y+i/2),m(e.x-t/2,e.y+i/2)];if(c!==0)for(let s=0;s<4;s++)o[s]=T(o[s],e,c);const n=$(o),u=Math.hypot(t,i)/2;return{type:g.RECTANGLE,width:t,height:i,center:e,vertices:o,faceNormals:n,bounds:u,boundingBox:J(g.RECTANGLE,u,o,e),sensor:a,sensorColliding:!1,inertia:0,angle:c}}x.createRectangleShape=U;function F(e,t,i,c,a,o,n){const u={id:e.nextId++,center:t,friction:c,restitution:a,shapes:o,static:!0,angle:0,permeability:0,data:n??null};for(const s of o)s.inertia=K(s,i);return i?{...u,static:!1,averageCenter:m(t.x,t.y),centerOfPhysics:{...t},mass:1/i,velocity:m(0,0),acceleration:e.gravity,averageAngle:0,angularVelocity:0,angularAcceleration:0,inertia:K(o[0],i),restingTime:0,fixedPosition:!1,fixedRotation:!1}:u}x.createRigidBody=F;function me(e,t,i){t.static?e.staticBodies.push(t):(i??e.dynamicBodies).push(t)}x.addBody=me;function pe(e,t,i){const c=t.static?e.staticBodies:i??e.dynamicBodies,a=c.findIndex(o=>o.id==t.id);a>=0&&c.splice(a,1)}x.removeBody=pe;function ge(e,t){for(const i of e.shapes)for(const c of t.shapes){const a=Math.abs(i.center.x-c.center.x)<i.boundingBox.x+c.boundingBox.x,o=Math.abs(i.center.y-c.center.y)<i.boundingBox.y+c.boundingBox.y;if(a&&o)return!0}return!1}function Z(e){e.boundingBox=J(e.type,e.bounds,e.type===g.RECTANGLE?e.vertices:[],e.center)}function J(e,t,i,c){if(e===g.CIRCLE)return{x:t,y:t};{let a=0,o=0;for(const n of i)a=Math.max(a,Math.abs(c.x-n.x)),o=Math.max(o,Math.abs(c.y-n.y));return{x:a,y:o}}}function Be(e){e.faceNormals=$(e.vertices)}function $(e){const t=[];for(let i=4;i--;)t[i]=V(p(e[(i+1)%4],e[(i+2)%4]));return t}function w(e,t,i){let c,a,o,n,u=1e9,s=-1,r=!0,y,f;for(a=4;r&&a--;){c=e.faceNormals[a];const l=d(c,-1),v=e.vertices[a];let C,h;for(f=-1e9,y=-1,o=4;o--;)C=p(t.vertices[o],v),h=R(C,l),h>0&&h>f&&(y=t.vertices[o],f=h);r=y!==-1,r&&f<u&&(u=f,s=a,n=y)}return r&&E(i,u,e.faceNormals[s],B(n,d(e.faceNormals[s],u)),e,t),r}function P(e,t){return t.static?!0:t.restingTime>e.restTime}function he(e,t,i,c){if(P(e,t)&&P(e,i))return!1;for(let a of t.shapes)for(let o of i.shapes){if(a.type==g.CIRCLE&&o.type===g.CIRCLE){const n=p(o.center,a.center),u=a.bounds+o.bounds,s=M(n);if(s<=Math.sqrt(u*u)){const r=V(d(n,-1)),y=d(r,o.bounds);E(c,u-s,V(n),B(o.center,y),a,o);continue}continue}if(a.type==g.RECTANGLE&&o.type==g.RECTANGLE){let n=!1,u=!1;const s=k();if(n=w(a,o,s),n){const r=k();if(u=w(o,a,r),u)if(s.depth<r.depth){E(c,s.depth,s.normal,p(s.start,d(s.normal,s.depth)),s.shapeA,r.shapeB);continue}else{E(c,r.depth,d(r.normal,-1),r.start,r.shapeB,r.shapeA);continue}}continue}if(a.type===g.CIRCLE&&o.type===g.RECTANGLE&&([a,o]=[o,a]),a.type===g.RECTANGLE&&o.type===g.CIRCLE){let n=1,u=-1e9,s=0,r,y,f,l;for(r=4;r--;){if(f=o.center,y=p(f,a.vertices[r]),l=R(y,a.faceNormals[r]),l>0){u=l,s=r,n=0;break}l>u&&(u=l,s=r)}let v,C;if(n&&f){E(c,o.bounds-u,a.faceNormals[s],p(f,d(a.faceNormals[s],o.bounds)),a,o);continue}else if(f){let h=p(f,a.vertices[s]),b=p(a.vertices[(s+1)%4],a.vertices[s]),L=R(h,b);if(L<0){if(v=M(h),v>o.bounds)continue;C=V(h),E(c,o.bounds-v,C,B(f,d(C,-o.bounds)),a,o);continue}else if(h=p(f,a.vertices[(s+1)%4]),b=d(b,-1),L=R(h,b),L<0){if(v=M(h),v>o.bounds)continue;C=V(h),E(c,o.bounds-v,C,B(f,d(C,-o.bounds)),a,o);continue}else if(u<o.bounds){E(c,o.bounds-u,a.faceNormals[s],p(f,d(a.faceNormals[s],o.bounds)),a,o);continue}else continue}continue}}return c.depth>0}function ve(e,t,i,c){if(P(e,t)&&P(e,i))return!1;const a=t.static?0:t.mass,o=i.static?0:i.mass,n=t.static?0:t.inertia,u=i.static?0:i.inertia,s=c.depth/(a+o)*.8,r=d(c.normal,s),y=c.normal;if(r.x===0&&r.y===0)return!1;t.static||A(t,d(r,-a)),i.static||A(i,d(r,o));const f=d(c.start,o/(a+o)),l=d(c.end,a/(a+o)),v=B(f,l),C=p(v,t.static?t.center:t.centerOfPhysics),h=p(v,i.static?i.center:i.centerOfPhysics),b=t.static?m(0,0):B(t.velocity,m(-1*t.angularVelocity*C.y,t.angularVelocity*C.x)),L=i.static?m(0,0):B(i.velocity,m(-1*i.angularVelocity*h.y,i.angularVelocity*h.x)),O=p(L,b),ee=R(O,y);if(ee>0)return!1;const te=Math.min(t.restitution,i.restitution),Ce=Math.min(t.friction,i.friction),z=N(C,y),q=N(h,y),j=-(1+te)*ee/(a+o+z*z*n+q*q*u);let I=d(y,j);t.static||(t.fixedPosition||(t.velocity=p(t.velocity,d(I,t.mass))),t.fixedRotation||(t.angularVelocity-=z*j*t.inertia)),i.static||(i.fixedPosition||(i.velocity=B(i.velocity,d(I,i.mass))),i.fixedRotation||(i.angularVelocity+=q*j*i.inertia));const S=d(V(p(O,d(y,R(O,y)))),-1),X=N(C,S),Y=N(h,S);let G=-(1+te)*R(O,S)*Ce/(a+o+X*X*n+Y*Y*u);return G>j&&(G=j),I=d(S,G),t.static||(t.velocity=p(t.velocity,d(I,t.mass)),t.angularVelocity-=X*G*t.inertia,t.velocity.x*=e.damp,t.velocity.y*=e.damp,t.angularVelocity*=e.angularDamp),i.static||(i.velocity=B(i.velocity,d(I,i.mass)),i.angularVelocity+=Y*G*i.inertia,i.velocity.x*=e.damp,i.velocity.y*=e.damp,i.angularVelocity*=e.angularDamp),!0}})(physics||(physics={}));
