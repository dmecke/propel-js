"use strict";export var physics;(function(p){let g;(function(t){t[t.CIRCLE=0]="CIRCLE",t[t.RECTANGLE=1]="RECTANGLE"})(g=p.ShapeType||(p.ShapeType={}));function O(t,e){return[...e??t.dynamicBodies,...t.staticBodies,...t.disabledBodies]}p.allBodies=O;function Q(t,e){return[...e??t.dynamicBodies,...t.staticBodies]}p.enabledBodies=Q;function se(t,e,i){const n=(i??t.dynamicBodies).findIndex(f=>f.id===e.id);n!==-1&&(i??t.dynamicBodies).splice(n,1);const r=t.staticBodies.findIndex(f=>f.id===e.id);r!==-1&&t.staticBodies.splice(r,1),t.disabledBodies.includes(e)||t.disabledBodies.push(e)}p.disableBody=se;function ce(t,e,i){!e.static&&!(i??t.dynamicBodies).find(n=>n.id===e.id)&&(i??t.dynamicBodies).push(e),e.static&&!t.staticBodies.includes(e)&&t.staticBodies.push(e),t.disabledBodies.includes(e)&&t.disabledBodies.splice(t.disabledBodies.indexOf(e),1)}p.enableBody=ce;function oe(t,e=!1,i){const n=e?t.staticBodies:O(t,i);if(n.length===0)return{min:B(0,0),max:B(0,0)};const r=n[0];let f=B(r.shapes[0].center.x-r.shapes[0].bounds,r.center.y-r.shapes[0].bounds),s=B(r.shapes[0].center.x+r.shapes[0].bounds,r.center.y+r.shapes[0].bounds);for(const x of n)for(const o of x.shapes)if(o.type===g.CIRCLE)f.x=Math.min(f.x,o.center.x-o.bounds),f.y=Math.min(f.y,o.center.y-o.bounds),s.x=Math.max(s.x,o.center.x+o.bounds),s.y=Math.max(s.y,o.center.y+o.bounds);else if(o.type===g.RECTANGLE)for(const a of o.vertices)f.x=Math.min(f.x,a.x),f.y=Math.min(f.y,a.y),s.x=Math.max(s.x,a.x),s.y=Math.max(s.y,a.y);return{min:f,max:s}}p.getWorldBounds=oe;function re(t,e=1){return{staticBodies:[],dynamicBodies:[],disabledBodies:[],gravity:t??B(0,100),angularDamp:1,damp:1,nextId:1,joints:[],frameCount:0,jointRestriction:1,restTime:e,exclusions:{},paused:!1}}p.createWorld=re;function fe(t,e,i){t.exclusions[e.id]=t.exclusions[e.id]??[],t.exclusions[e.id].includes(i.id)||t.exclusions[e.id].push(i.id),t.exclusions[i.id]=t.exclusions[i.id]??[],t.exclusions[i.id].includes(e.id)||t.exclusions[i.id].push(e.id)}p.excludeCollisions=fe;function ue(t,e,i){t.exclusions[e.id]&&(t.exclusions[e.id]=t.exclusions[e.id].filter(n=>i.id===n)),t.exclusions[i.id]&&(t.exclusions[i.id]=t.exclusions[e.id].filter(n=>e.id===n))}p.includeCollisions=ue;function le(t,e,i,n=1,r=0,f=!1){const s={bodyA:e.type==="BODY"?e.id:e.bodyId,bodyB:i.type==="BODY"?i.id:i.bodyId,distance:0,rigidity:n,elasticity:r,soft:f,shapeA:e.type!=="BODY"?e.id:0,shapeB:i.type!=="BODY"?i.id:0},x=O(t).find(u=>u.id===s.bodyA),o=O(t).find(u=>u.id===s.bodyB);if(!x||!o)throw"Body A is not part of world. Joints must be connected to elements in the world";const a=s.shapeA?x.shapes.find(u=>u.id===s.shapeA).center:x.center,d=s.shapeB?o.shapes.find(u=>u.id===s.shapeB).center:o.center;s.distance=M(m(a,d)),t.joints.push(s)}p.createJoint=le;function de(t,e,i,n,r,f,s=!1,x){const o=$(t,e,i,s);return z(t,e,n,r,f,[o],x)}p.createCircle=de;function pe(t,e,i,n,r,f,s,x=!1,o){const a=w(t,e,i,n,0,x);return z(t,e,r,f,s,[a],o)}p.createRectangle=pe;function U(t,e){L(t,e,!0)}p.moveBody=U;function L(t,e,i=!1){if(!(!i&&t.static)){t.center=v(t.center,e),t.static||(t.centerOfPhysics=v(t.centerOfPhysics,e));for(const n of t.shapes)if(n.center=v(n.center,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=v(n.vertices[r],e);te(n)}}}function xe(t,e){const i=m(e,t.center);U(t,i)}p.setCenter=xe;function ye(t,e){const i=e-t.angle;t.static||(t.centerOfPhysics={...t.center}),F(t,i)}p.setRotation=ye;function F(t,e){if(!e)return;t.angle+=e,t.static||(t.averageAngle=e);const i=t.static?t.center:t.centerOfPhysics;t.center=G(t.center,i,e);for(const n of t.shapes)if(n.center=G(n.center,i,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=G(n.vertices[r],i,e);Re(n),te(n)}}p.rotateBody=F;function he(t,e,i,n,r){const f=e.bodyA===i.id?e.shapeA:e.shapeB,s=e.bodyA===i.id?e.shapeB:e.shapeA,x=f?i.shapes.find(c=>c.id===f).center:i.center,o=s?n.shapes.find(c=>c.id===s).center:n.center;let a=m(o,x);if(M(a)-e.distance!=0){if(!i.static){const C=m(i.centerOfPhysics,x);if(M(C)>0){let h=Math.atan2(-a.y,-a.x)-Math.atan2(C.y,C.x);h>Math.PI&&(h=Math.PI-h),h<-Math.PI&&(h=Math.PI*2+h),i.angularVelocity+=h/r}}a=m(o,x);const c=M(a),y=c-e.distance;y!=0&&(y>0?a=l(a,1/c*y*(1-e.elasticity)*(n.static?1:.5)):a=l(a,1/c*y*e.rigidity*(n.static?1:.5)),!e.soft&&!i.static&&L(i,a),!e.soft&&!n.static&&L(n,l(a,-1)),i.static||(i.velocity=v(i.velocity,l(a,e.soft?1:r/2))),n.static||(n.velocity=v(n.velocity,l(a,-(e.soft?1:r/2)))))}}function me(t,e,i){if(e.paused)return[];i=i??e.dynamicBodies;const n=Q(e,i),r=O(e,i);let f=[];for(const s of r)s.shapes.forEach(x=>{!s.static&&s.restingTime>e.restTime||(x.sensorColliding=!1)});for(const s of i)!s.velocity&&!s.acceleration||S(e,s)||(s.fixedPosition?(s.velocity.x=0,s.velocity.y=0):(s.velocity=v(s.velocity,l(s.acceleration,1/t)),L(s,l(s.velocity,1/t))),s.fixedRotation?(s.angularVelocity=0,s.angularAcceleration=0):(s.angularVelocity+=s.angularAcceleration*1/t,F(s,s.angularVelocity*1/t)));for(let s=9;s--;){let x=!1;for(const o of i){const a=e.joints.filter(d=>d.bodyA===o.id||d.bodyB===o.id);for(const d of a){const u=d.bodyA===o.id?d.bodyB:d.bodyA,c=r.find(y=>y.id===u);c&&(he(e,d,o,c,t),(o.static||c.static)&&(o.static||(o.velocity.x-=o.velocity.x*(1-e.damp)/t*e.jointRestriction,o.velocity.y-=o.velocity.y*(1-e.damp)/t*e.jointRestriction,o.angularVelocity-=o.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction),c.static||(c.velocity.x-=c.velocity.x*(1-e.damp)/t*e.jointRestriction,c.velocity.y-=c.velocity.y*(1-e.damp)/t*e.jointRestriction,c.angularVelocity-=c.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction)))}}for(let o=i.length;o--;){const a=i[o];if(a.velocity)for(let d=n.length;d-- >o;){if(o===d)continue;const u=n[d];if(!e.exclusions[u.id]?.includes(a.id)&&!e.exclusions[a.id]?.includes(u.id)&&ee(a,u)){let c=j();if(ae(e,a,u,c)){if(c.shapeA&&c.shapeA.sensor){c.shapeA.sensorColliding=!0;continue}if(c.shapeB&&c.shapeB.sensor){c.shapeB.sensorColliding=!0;continue}if(u.permeability>0){a.velocity.x*=1-u.permeability,a.velocity.y*=1-u.permeability,a.angularVelocity*=1-u.permeability;continue}a.static||(a.shapes.includes(c.shapeA)&&!c.shapeA.sensor&&(a.centerOfPhysics={...c.shapeA.center},a.inertia=c.shapeA.inertia),a.shapes.includes(c.shapeB)&&!c.shapeB.sensor&&(a.centerOfPhysics={...c.shapeB.center},a.inertia=c.shapeB.inertia)),u.static||(u.shapes.includes(c.shapeA)&&!c.shapeA.sensor&&(u.centerOfPhysics={...c.shapeA.center},u.inertia=c.shapeA.inertia),u.shapes.includes(c.shapeB)&&!c.shapeB.sensor&&(u.centerOfPhysics={...c.shapeB.center},u.inertia=c.shapeB.inertia)),A(c.normal,m(u.center,a.center))<0&&(c={depth:c.depth,normal:l(c.normal,-1),start:c.end,end:c.start,shapeA:c.shapeB,shapeB:c.shapeA}),Ae(e,a,u,c)&&(x=!0,f=f.filter(y=>y.bodyAId!==a.id&&y.bodyBId!==u.id),f.push({bodyAId:a.id,bodyBId:u.id,depth:c.depth,start:c.start}))}}}}if(!x)break}for(const s of i)s.restingTime+=1/t,Math.abs(s.center.x-s.averageCenter.x)>.1&&(s.averageCenter.x=s.center.x,s.restingTime=0),Math.abs(s.center.y-s.averageCenter.y)>.1&&(s.averageCenter.y=s.center.y,s.restingTime=0),Math.abs(s.angle-s.averageAngle)>=.05&&(s.averageAngle=s.angle,s.restingTime=0);return f}p.worldStep=me;function Be(t,e,i=!1){const n=t.staticBodies;for(const r of n)if(ee(e,r)){i&&i&&console.log("Collide",e.center.y,r.center.y,e.shapes[0],r.shapes[0]);let f=j();if(ae(t,e,r,f))return!0}return!1}p.collidingWithStatic=Be;function ge(t,e=1,i){return!(i??t.dynamicBodies).find(n=>n.restingTime<e)}p.atRest=ge;function B(t,e){return{x:t,y:e}}p.newVec2=B;function M(t){return A(t,t)**.5}p.lengthVec2=M;function v(t,e){return B(t.x+e.x,t.y+e.y)}p.addVec2=v;function m(t,e){return v(t,l(e,-1))}p.subtractVec2=m;function l(t,e){return B(t.x*e,t.y*e)}p.scaleVec2=l;function A(t,e){return t.x*e.x+t.y*e.y}p.dotProduct=A;function b(t,e){return t.x*e.y-t.y*e.x}p.crossProduct=b;function G(t,e,i){const n=t.x-e.x,r=t.y-e.y;return B(n*Math.cos(i)-r*Math.sin(i)+e.x,n*Math.sin(i)+r*Math.cos(i)+e.y)}p.rotateVec2=G;function P(t){return l(t,1/(M(t)||1))}p.normalize=P;const j=()=>({depth:0,normal:B(0,0),start:B(0,0),end:B(0,0),shapeA:void 0,shapeB:void 0});function V(t,e,i,n,r,f){if(!(t.depth>=e)){if(r.sensor){r.sensorColliding=!0;return}if(f.sensor){f.sensorColliding=!0;return}t.depth=e,t.normal.x=i.x,t.normal.y=i.y,t.start.x=n.x,t.start.y=n.y,t.end=v(n,l(i,e)),t.shapeA=r,t.shapeB=f}}function Z(t,e){return t.type===g.RECTANGLE?(Math.hypot(t.width,t.height)/2,e>0?1/(e*(t.width**2+t.height**2)/12):0):e>0?e*t.bounds**2/12:0}function $(t,e,i,n=!1){return e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),{id:t.nextId++,type:g.CIRCLE,center:e,bounds:i,boundingBox:q(g.CIRCLE,i,[],e),sensor:n,sensorColliding:!1,inertia:0}}p.createCircleShape=$;function w(t,e,i,n,r=0,f=!1){e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),n=Math.floor(n);const s=[B(e.x-i/2,e.y-n/2),B(e.x+i/2,e.y-n/2),B(e.x+i/2,e.y+n/2),B(e.x-i/2,e.y+n/2)];if(r!==0)for(let a=0;a<4;a++)s[a]=G(s[a],e,r);const x=ie(s),o=Math.hypot(i,n)/2;return{id:t.nextId++,type:g.RECTANGLE,width:i,height:n,center:e,vertices:s,faceNormals:x,bounds:o,boundingBox:q(g.RECTANGLE,o,s,e),sensor:f,sensorColliding:!1,inertia:0,angle:r}}p.createRectangleShape=w;function z(t,e,i,n,r,f,s,x=!1){const o={id:t.nextId++,center:e,friction:n,restitution:r,shapes:f,static:!0,angle:0,permeability:0,data:s??null,type:"BODY"};for(const a of f)a.inertia=Z(a,i),a.bodyId=o.id;return i?{...o,static:!1,averageCenter:B(e.x,e.y),centerOfPhysics:{...e},mass:1/i,velocity:B(0,0),acceleration:x?{x:0,y:0}:t.gravity,averageAngle:0,angularVelocity:0,angularAcceleration:0,inertia:Z(f[0],i),restingTime:0,fixedPosition:!1,fixedRotation:!1,floating:x}:o}p.createRigidBody=z;function ve(t,e,i){e.static?t.staticBodies.push(e):(i??t.dynamicBodies).push(e)}p.addBody=ve;function Ce(t,e,i){const n=e.static?t.staticBodies:i??t.dynamicBodies,r=n.findIndex(f=>f.id==e.id);r>=0&&n.splice(r,1)}p.removeBody=Ce;function ee(t,e){for(const i of t.shapes)for(const n of e.shapes){const r=Math.abs(i.center.x-n.center.x)<i.boundingBox.x+n.boundingBox.x,f=Math.abs(i.center.y-n.center.y)<i.boundingBox.y+n.boundingBox.y;if(r&&f)return!0}return!1}function te(t){t.boundingBox=q(t.type,t.bounds,t.type===g.RECTANGLE?t.vertices:[],t.center)}function q(t,e,i,n){if(t===g.CIRCLE)return{x:e,y:e};{let r=0,f=0;for(const s of i)r=Math.max(r,Math.abs(n.x-s.x)),f=Math.max(f,Math.abs(n.y-s.y));return{x:r,y:f}}}function Re(t){t.faceNormals=ie(t.vertices)}function ie(t){const e=[];for(let i=4;i--;)e[i]=P(m(t[(i+1)%4],t[(i+2)%4]));return e}function ne(t,e,i){let n,r,f,s,x=1e9,o=-1,a=!0,d,u;for(r=4;a&&r--;){n=t.faceNormals[r];const c=l(n,-1),y=t.vertices[r];let C,h;for(u=-1e9,d=-1,f=4;f--;)C=m(e.vertices[f],y),h=A(C,c),h>0&&h>u&&(d=e.vertices[f],u=h);a=d!==-1,a&&u<x&&(x=u,o=r,s=d)}return a&&V(i,x,t.faceNormals[o],v(s,l(t.faceNormals[o],x)),t,e),a}function S(t,e){return e.static?!0:e.restingTime>t.restTime}function ae(t,e,i,n){if(S(t,e)&&S(t,i))return!1;let r=e,f=i;for(let s of e.shapes)for(let x of i.shapes){let o=s,a=x;if(e=r,i=f,o.type==g.CIRCLE&&a.type===g.CIRCLE){const d=m(a.center,o.center),u=o.bounds+a.bounds,c=M(d);if(c<=Math.sqrt(u*u)){const y=P(l(d,-1)),C=l(y,a.bounds);V(n,u-c,P(d),v(a.center,C),o,a);continue}continue}if(o.type==g.RECTANGLE&&a.type==g.RECTANGLE){let d=!1,u=!1;const c=j();if(d=ne(o,a,c),d){const y=j();if(u=ne(a,o,y),u)if(c.depth<y.depth){V(n,c.depth,c.normal,m(c.start,l(c.normal,c.depth)),c.shapeA,y.shapeB);continue}else{V(n,y.depth,l(y.normal,-1),y.start,y.shapeB,y.shapeA);continue}}continue}if(o.type===g.CIRCLE&&a.type===g.RECTANGLE&&([o,a]=[a,o]),o.type===g.RECTANGLE&&a.type===g.CIRCLE){let d=1,u=-1e9,c=0,y,C,h,N;for(y=4;y--;){if(h=a.center,C=m(h,o.vertices[y]),N=A(C,o.faceNormals[y]),N>0){u=N,c=y,d=0;break}N>u&&(u=N,c=y)}let I,R;if(d&&h){V(n,a.bounds-u,o.faceNormals[c],m(h,l(o.faceNormals[c],a.bounds)),o,a);continue}else if(h){let E=m(h,o.vertices[c]),T=m(o.vertices[(c+1)%4],o.vertices[c]),D=A(E,T);if(D<0){if(I=M(E),I>a.bounds)continue;R=P(E),V(n,a.bounds-I,R,v(h,l(R,-a.bounds)),o,a);continue}else if(E=m(h,o.vertices[(c+1)%4]),T=l(T,-1),D=A(E,T),D<0){if(I=M(E),I>a.bounds)continue;R=P(E),V(n,a.bounds-I,R,v(h,l(R,-a.bounds)),o,a);continue}else if(u<a.bounds){V(n,a.bounds-u,o.faceNormals[c],m(h,l(o.faceNormals[c],a.bounds)),o,a);continue}else continue}continue}}return n.depth>0}function Ae(t,e,i,n){if(S(t,e)&&S(t,i))return!1;const r=e.static?0:e.mass,f=i.static?0:i.mass,s=e.static?0:e.inertia,x=i.static?0:i.inertia,o=n.depth/(r+f)*.8,a=l(n.normal,o),d=n.normal;if(a.x===0&&a.y===0)return!1;e.static||L(e,l(a,-r)),i.static||L(i,l(a,f));const u=l(n.start,f/(r+f)),c=l(n.end,r/(r+f)),y=v(u,c),C=m(y,e.static?e.center:e.centerOfPhysics),h=m(y,i.static?i.center:i.centerOfPhysics),N=e.static?B(0,0):v(e.velocity,B(-1*e.angularVelocity*C.y,e.angularVelocity*C.x)),I=i.static?B(0,0):v(i.velocity,B(-1*i.angularVelocity*h.y,i.angularVelocity*h.x)),R=m(I,N),E=A(R,d);if(E>0)return!1;const T=Math.min(e.restitution,i.restitution),D=Math.min(e.friction,i.friction),X=b(C,d),_=b(h,d),J=-(1+T)*E/(r+f+X*X*s+_*_*x);let W=l(d,J);e.static||(e.fixedPosition||(e.velocity=m(e.velocity,l(W,e.mass))),e.fixedRotation||(e.angularVelocity-=X*J*e.inertia)),i.static||(i.fixedPosition||(i.velocity=v(i.velocity,l(W,i.mass))),i.fixedRotation||(i.angularVelocity+=_*J*i.inertia));const k=l(P(m(R,l(d,A(R,d)))),-1),H=b(C,k),K=b(h,k);let Y=-(1+T)*A(R,k)*D/(r+f+H*H*s+K*K*x);return Y>J&&(Y=J),W=l(k,Y),e.static||(e.velocity=m(e.velocity,l(W,e.mass)),e.angularVelocity-=H*Y*e.inertia,e.velocity.x*=t.damp,e.velocity.y*=t.damp,e.angularVelocity*=t.angularDamp),i.static||(i.velocity=v(i.velocity,l(W,i.mass)),i.angularVelocity+=K*Y*i.inertia,i.velocity.x*=t.damp,i.velocity.y*=t.damp,i.angularVelocity*=t.angularDamp),!0}})(physics||(physics={}));
